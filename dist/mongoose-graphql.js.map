{"version":3,"file":null,"sources":["../lib/getType.js","../lib/getTypeObjects.js","../lib/getTypeTree.js","../lib/index.js"],"sourcesContent":["/* eslint-disable import/prefer-default-export */\n\nconst getType = typeObject => {\n    let typeString = `type ${typeObject.type} {\\n`;\n\n    Object.keys(typeObject.properties)\n        .sort()\n        .forEach(key => {\n            typeString += `  ${key}: ${typeObject.properties[key]}\\n`;\n        });\n\n    typeString += '}';\n\n    return typeString;\n};\n\nexport default getType;\n","import { forOwn, upperFirst } from 'lodash';\nimport pluralize from 'pluralize';\n\nconst getTypeObjects = (name, typeTree) => {\n    let typeObjects = [];\n\n    const currentType = {\n        type: name,\n        properties: {}\n    };\n\n    forOwn(typeTree, (value, key) => {\n        const isArray = Array.isArray(value);\n        const typeValue = isArray ? value[0] : value;\n\n        let type;\n        if (typeof typeValue === 'object') {\n            const childTypeName = pluralize(`${name}${upperFirst(key)}`, 1);\n\n            // Add the child type objects to the front\n            const childTypeObjects = getTypeObjects(childTypeName, typeValue);\n            typeObjects = childTypeObjects.concat(typeObjects);\n\n            type = childTypeName;\n        } else {\n            type = typeValue;\n        }\n\n        if (isArray) {\n            type = `[${type}]`;\n        }\n\n        currentType.properties[key] = type;\n    });\n\n    if (Object.keys(currentType.properties).length > 0) {\n        typeObjects.push(currentType);\n    }\n\n    return typeObjects;\n};\n\nexport default getTypeObjects;\n","/* eslint-disable no-use-before-define */\nimport { forOwn } from 'lodash';\n\nconst setDescendant = (tree, key, value) => {\n    let parentTree = tree;\n\n    // Make sure there is an object for each of the ancestors\n    // Ex. 'location.address.street1'' -> { location: { address: {} } }\n    const splitPath = key.split('.');\n    for (let i = 0; i < splitPath.length - 1; i += 1) {\n        const ancestor = splitPath[i];\n        parentTree[ancestor] = parentTree[ancestor] || {};\n        parentTree = parentTree[ancestor];\n    }\n\n    const property = splitPath[splitPath.length - 1];\n    parentTree[property] = value;\n};\n\nconst instanceToType = instance => {\n    switch (instance) {\n        case 'Boolean':\n            return 'Boolean';\n        case 'ObjectID':\n        case 'String':\n            return 'String';\n        case 'Date':\n        case 'Number':\n            return 'Float';\n        default:\n            throw new Error(`${instance} not implemented yet in instanceToType`);\n    }\n};\n\nconst refToType = instance => {\n    return instance;\n};\n\nconst arrayToTree = path => {\n    if (path.caster && path.caster.instance) {\n        // If a \"ref\" is specified (model utilizes Mongoose population), use the ref name or override\n        if (path.caster.options && path.caster.options.ref) {\n            return [refToType(path.caster.options.ref)];\n        }\n        return [instanceToType(path.caster.instance)];\n    } else if (path.casterConstructor) {\n        return [getTypeTree(path.casterConstructor.schema.paths)];\n    }\n\n    throw new Error(`${path} is not a supported path`);\n};\n\nconst getTypeTree = schemaPaths => {\n    const typeTree = {};\n\n    forOwn(schemaPaths, (path, key) => {\n        if (key === '__v') {\n            return;\n        }\n\n        let value;\n\n        if (path.instance === 'Array') {\n            value = arrayToTree(path);\n        } else if (path.instance === 'Embedded') {\n            value = getTypeTree(path.caster.schema.paths);\n        } else {\n            value = path.options && path.options.ref ? refToType(path.options.ref) : instanceToType(path.instance);\n        }\n\n        setDescendant(typeTree, key, value);\n    });\n\n    return typeTree;\n};\n\nexport default getTypeTree;\n","/* eslint-disable import/prefer-default-export */\nimport { find, forOwn, filter, includes, replace, omit } from 'lodash';\n\nimport getType from './getType';\nimport getTypeObjects from './getTypeObjects';\nimport getTypeTree from './getTypeTree';\n\nexport const modelToType = (model, options = {}) => {\n    const schema = model.schema;\n    let typeTree = getTypeTree(schema.paths);\n\n    // Remove any fields from the typeTree that should be omitted\n    if (options.omit) {\n        if (Array.isArray(options.omit)) {\n            if (options.omit.length) {\n                typeTree = omit(typeTree, options.omit);\n            }\n        } else {\n            console.error('options.omit must be an array');\n        }\n    }\n\n    const typeObjects = getTypeObjects(options.name || model.modelName, typeTree);\n\n    if (options.extend) {\n        forOwn(options.extend, (extension, type) => {\n            const typeObject = find(typeObjects, t => t.type === type);\n            Object.assign(typeObject.properties, extension);\n        });\n    }\n\n    // Override refs\n    if (options.refs) {\n        forOwn(options.refs, (ref, type) => {\n            typeObjects.forEach(typeObject => {\n                Object.keys(typeObject.properties).forEach(key => {\n                    if (includes(typeObject.properties[key], type)) {\n                        typeObject.properties[key] = replace(typeObject.properties[key], type, ref);\n                    }\n                });\n            });\n        });\n    }\n\n    const typeStrings = typeObjects.map(getType);\n    return typeStrings.join('\\n');\n};\n"],"names":["getType","typeString","typeObject","type","keys","properties","sort","forEach","key","getTypeObjects","name","typeTree","typeObjects","currentType","value","isArray","Array","typeValue","childTypeName","pluralize","upperFirst","childTypeObjects","concat","Object","length","push","setDescendant","tree","parentTree","splitPath","split","i","ancestor","property","instanceToType","instance","Error","refToType","arrayToTree","path","caster","options","ref","casterConstructor","getTypeTree","schema","paths","schemaPaths","modelToType","model","omit","error","modelName","extend","extension","find","t","assign","refs","includes","replace","typeStrings","map","join"],"mappings":";;;;;;;;AAAA;;AAEA,IAAMA,UAAU,SAAVA,OAAU,aAAc;QACtBC,uBAAqBC,WAAWC,IAAhC,SAAJ;;WAEOC,IAAP,CAAYF,WAAWG,UAAvB,EACKC,IADL,GAEKC,OAFL,CAEa,eAAO;6BACOC,GAAnB,UAA2BN,WAAWG,UAAX,CAAsBG,GAAtB,CAA3B;KAHR;;kBAMc,GAAd;;WAEOP,UAAP;CAXJ,CAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA,IAAMQ,iBAAiB,SAAjBA,cAAiB,CAACC,IAAD,EAAOC,QAAP,EAAoB;QACnCC,cAAc,EAAlB;;QAEMC,cAAc;cACVH,IADU;oBAEJ;KAFhB;;kBAKOC,QAAP,EAAiB,UAACG,KAAD,EAAQN,GAAR,EAAgB;YACvBO,UAAUC,MAAMD,OAAN,CAAcD,KAAd,CAAhB;YACMG,YAAYF,UAAUD,MAAM,CAAN,CAAV,GAAqBA,KAAvC;;YAEIX,aAAJ;YACI,QAAOc,SAAP,yCAAOA,SAAP,OAAqB,QAAzB,EAAmC;gBACzBC,gBAAgBC,eAAaT,IAAb,GAAoBU,kBAAWZ,GAAX,CAApB,EAAuC,CAAvC,CAAtB;;;gBAGMa,mBAAmBZ,eAAeS,aAAf,EAA8BD,SAA9B,CAAzB;0BACcI,iBAAiBC,MAAjB,CAAwBV,WAAxB,CAAd;;mBAEOM,aAAP;SAPJ,MAQO;mBACID,SAAP;;;YAGAF,OAAJ,EAAa;yBACEZ,IAAX;;;oBAGQE,UAAZ,CAAuBG,GAAvB,IAA8BL,IAA9B;KArBJ;;QAwBIoB,OAAOnB,IAAP,CAAYS,YAAYR,UAAxB,EAAoCmB,MAApC,GAA6C,CAAjD,EAAoD;oBACpCC,IAAZ,CAAiBZ,WAAjB;;;WAGGD,WAAP;CApCJ,CAuCA;;AC1CA;AACA,AAEA,IAAMc,gBAAgB,SAAhBA,aAAgB,CAACC,IAAD,EAAOnB,GAAP,EAAYM,KAAZ,EAAsB;QACpCc,aAAaD,IAAjB;;;;QAIME,YAAYrB,IAAIsB,KAAJ,CAAU,GAAV,CAAlB;SACK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,UAAUL,MAAV,GAAmB,CAAvC,EAA0CO,KAAK,CAA/C,EAAkD;YACxCC,WAAWH,UAAUE,CAAV,CAAjB;mBACWC,QAAX,IAAuBJ,WAAWI,QAAX,KAAwB,EAA/C;qBACaJ,WAAWI,QAAX,CAAb;;;QAGEC,WAAWJ,UAAUA,UAAUL,MAAV,GAAmB,CAA7B,CAAjB;eACWS,QAAX,IAAuBnB,KAAvB;CAbJ;;AAgBA,IAAMoB,iBAAiB,SAAjBA,cAAiB,WAAY;YACvBC,QAAR;aACS,SAAL;mBACW,SAAP;aACC,UAAL;aACK,QAAL;mBACW,QAAP;aACC,MAAL;aACK,QAAL;mBACW,OAAP;;kBAEM,IAAIC,KAAJ,CAAaD,QAAb,4CAAN;;CAXZ;;AAeA,IAAME,YAAY,SAAZA,SAAY,WAAY;WACnBF,QAAP;CADJ;;AAIA,IAAMG,cAAc,SAAdA,WAAc,OAAQ;QACpBC,KAAKC,MAAL,IAAeD,KAAKC,MAAL,CAAYL,QAA/B,EAAyC;;YAEjCI,KAAKC,MAAL,CAAYC,OAAZ,IAAuBF,KAAKC,MAAL,CAAYC,OAAZ,CAAoBC,GAA/C,EAAoD;mBACzC,CAACL,UAAUE,KAAKC,MAAL,CAAYC,OAAZ,CAAoBC,GAA9B,CAAD,CAAP;;eAEG,CAACR,eAAeK,KAAKC,MAAL,CAAYL,QAA3B,CAAD,CAAP;KALJ,MAMO,IAAII,KAAKI,iBAAT,EAA4B;eACxB,CAACC,YAAYL,KAAKI,iBAAL,CAAuBE,MAAvB,CAA8BC,KAA1C,CAAD,CAAP;;;UAGE,IAAIV,KAAJ,CAAaG,IAAb,8BAAN;CAXJ;;AAcA,IAAMK,cAAc,SAAdA,WAAc,cAAe;QACzBjC,WAAW,EAAjB;;kBAEOoC,WAAP,EAAoB,UAACR,IAAD,EAAO/B,GAAP,EAAe;YAC3BA,QAAQ,KAAZ,EAAmB;;;;YAIfM,cAAJ;;YAEIyB,KAAKJ,QAAL,KAAkB,OAAtB,EAA+B;oBACnBG,YAAYC,IAAZ,CAAR;SADJ,MAEO,IAAIA,KAAKJ,QAAL,KAAkB,UAAtB,EAAkC;oBAC7BS,YAAYL,KAAKC,MAAL,CAAYK,MAAZ,CAAmBC,KAA/B,CAAR;SADG,MAEA;oBACKP,KAAKE,OAAL,IAAgBF,KAAKE,OAAL,CAAaC,GAA7B,GAAmCL,UAAUE,KAAKE,OAAL,CAAaC,GAAvB,CAAnC,GAAiER,eAAeK,KAAKJ,QAApB,CAAzE;;;sBAGUxB,QAAd,EAAwBH,GAAxB,EAA6BM,KAA7B;KAfJ;;WAkBOH,QAAP;CArBJ,CAwBA;;AC5EA;AACA,AAEA,AACA,AACA,AAEA,AAAO,IAAMqC,cAAc,SAAdA,WAAc,CAACC,KAAD,EAAyB;QAAjBR,OAAiB,uEAAP,EAAO;;QAC1CI,SAASI,MAAMJ,MAArB;QACIlC,WAAWiC,YAAYC,OAAOC,KAAnB,CAAf;;;QAGIL,QAAQS,IAAZ,EAAkB;YACVlC,MAAMD,OAAN,CAAc0B,QAAQS,IAAtB,CAAJ,EAAiC;gBACzBT,QAAQS,IAAR,CAAa1B,MAAjB,EAAyB;2BACV0B,YAAKvC,QAAL,EAAe8B,QAAQS,IAAvB,CAAX;;SAFR,MAIO;oBACKC,KAAR,CAAc,+BAAd;;;;QAIFvC,cAAcH,eAAegC,QAAQ/B,IAAR,IAAgBuC,MAAMG,SAArC,EAAgDzC,QAAhD,CAApB;;QAEI8B,QAAQY,MAAZ,EAAoB;sBACTZ,QAAQY,MAAf,EAAuB,UAACC,SAAD,EAAYnD,IAAZ,EAAqB;gBAClCD,aAAaqD,YAAK3C,WAAL,EAAkB;uBAAK4C,EAAErD,IAAF,KAAWA,IAAhB;aAAlB,CAAnB;mBACOsD,MAAP,CAAcvD,WAAWG,UAAzB,EAAqCiD,SAArC;SAFJ;;;;QAOAb,QAAQiB,IAAZ,EAAkB;sBACPjB,QAAQiB,IAAf,EAAqB,UAAChB,GAAD,EAAMvC,IAAN,EAAe;wBACpBI,OAAZ,CAAoB,sBAAc;uBACvBH,IAAP,CAAYF,WAAWG,UAAvB,EAAmCE,OAAnC,CAA2C,eAAO;wBAC1CoD,gBAASzD,WAAWG,UAAX,CAAsBG,GAAtB,CAAT,EAAqCL,IAArC,CAAJ,EAAgD;mCACjCE,UAAX,CAAsBG,GAAtB,IAA6BoD,eAAQ1D,WAAWG,UAAX,CAAsBG,GAAtB,CAAR,EAAoCL,IAApC,EAA0CuC,GAA1C,CAA7B;;iBAFR;aADJ;SADJ;;;QAWEmB,cAAcjD,YAAYkD,GAAZ,CAAgB9D,OAAhB,CAApB;WACO6D,YAAYE,IAAZ,CAAiB,IAAjB,CAAP;CAtCG;;;;;;"}